---
title: "Tutorial"
author: "Yufang Liu"
date: "2023-09-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introductino for OMIC

This file is a brief tutorial for our proposed method Orthogonal Multimodality Integration and Clustering in
Multimodal Single-cell Data (OMIC). This tutorial contains the instructions of the main functions of OMIC, including the data preprocessing, the clustering, and interpretation of model coefficients, which provides quantification of additional prediction power for each variable, and determining which RNAs and ADTs are differentially expressed to provide significant prediction power.

## 1. Load Packages

Load the requaired package for the tutorial. The detailed list of the required packages are presented in the read_me file.

```{r}
library(Seurat)
library(SeuratData)
library(dplyr)
library(ggplot2)
library(mclust)
library(pROC)
library(caret)
```

## 2. Read data

Load the data from Human Bone Marrow Cells (HBMC). This dataset consists of 30,672 cells and
25 antibodies. We perform normalization to RNA and ADT count matrix and then screen out certain features for RNA. 

```{r}
#Load data
bm=LoadData('bmcite')

### Normalization, feature selection and get PCA components for RNA
DefaultAssay(bm) <- 'RNA'
bm <- NormalizeData(bm) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA()

### Normalization and feature selection for ADT
DefaultAssay(bm) <- 'ADT'
VariableFeatures(bm) <- rownames(bm[["ADT"]])
bm <- NormalizeData(bm, normalization.method = 'CLR', margin = 2) %>%
  ScaleData()
```

## 3. Train the model
```{r}
n.adt.pc = 25

#Get RNA and ADT scaled matrix
rna = t(bm@assays$RNA@scale.data)
adt = t(bm@assays$ADT@scale.data)

#Train the model
model=lm(adt~rna)

#Get ADT residuals
adt.reduce=model$residuals

#Get RNA components
rna.emb = bm@reductions$pca@cell.embeddings[,1:30]
colnames(adt.reduce)=c(1:25)
colnames=colnames(adt.reduce)
colnames=paste("apca_",colnames,sep="")
colnames(adt.reduce)=colnames

#Integrate ADT residuals and RNA for clustering
integrate.data = t(scale(data.frame(cbind(rna.emb,adt.reduce))))
```


## 4. Clustering

The evaluation of the clustering performance is presented by calculating the adjusted rand index between the clustering result and the manually annotated labels.
```{r}
#Use ADT residuals and RNA for clustering
bm.integrate = bm
bm.integrate@assays$integrate=CreateAssayObject(data = integrate.data)

DefaultAssay(bm.integrate) <- 'integrate'
bm.integrate@assays$integrate@key = "integrate_"
VariableFeatures(bm.integrate) <- rownames(bm.integrate[["integrate"]])

bm.integrate@reductions$integrateRed = CreateDimReducObject(embeddings = t(as.matrix(integrate.data)),
                                                              assay = "integrate",key = 'integrateRed_')

bm.integrate <- RunUMAP(bm.integrate, reduction = 'integrateRed',dims = 1:50,
                          reduction.name = "integrate.umap", reduction.key = "integrateUMAP_")
bm.integrate <- FindNeighbors(bm.integrate, reduction = 'integrateRed',dims = 1:50
                                , assay = 'integrate',graph.name = "intg_graph",k.param =20)

#Louvein algorithm for clustering
bm.integrate <- FindClusters(bm.integrate , graph.name = "intg_graph"
                               ,resolution = 1,method=3)
#Visualization
p4 <- DimPlot(bm.integrate, reduction = 'integrate.umap', label = TRUE,
              repel = TRUE, label.size = 5) + NoLegend() +ggtitle(NULL)
p5 <- DimPlot(bm.integrate, reduction = 'integrate.umap', group.by = 'celltype.l2', label = TRUE,
              repel = TRUE, label.size = 5) + NoLegend() +ggtitle(NULL)
p4+p5

adjustedRandIndex(bm.integrate$seurat_clusters, bm.integrate$celltype.l2)
```

## 5. Intepretability
Now we come to see how our model could detect, which RNAs and ADTs are differentially expressed to provide significant prediction power in clustering analysis. We perform logisitic regression in each cluster and examing the value of coefficients to determine additional prediction power for each variable.
```{r}
#Find differentially expressed RNA in each cluster
DefaultAssay(bm.integrate) <- 'RNA'
bm.markers <- FindAllMarkers(bm.integrate, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.75)
bm.markers %>%
  group_by(cluster) %>%
  slice_max(n = 2, order_by = avg_log2FC)


marker_index=list()

for(i in 1:16){
  marker_index[[i]]=which(bm.markers$cluster==i-1)
}

```



```{r, warning=FALSE}
ADT=t(bm.integrate$ADT@scale.data)
colnames(ADT)=noquote(paste('adt',colnames(ADT)))

test_adt=c()
train_adt=c()
test_rna=c()
train_rna=c()
test_adtrna=c()
train_adtrna=c()

#Divide into training set and testing set
separate <- sample(c(rep(0,21470), rep(1,9202)))
train=ADT[separate==0,]
test=ADT[separate==1,]
  
cluster=rep(0,30672)
cluster_list=c()
index_list=c()
model_list=c()

  
#Perform logistic regression on each cluster using only ADT information
for(i in 1:16){
    index_list[[i]]=which(bm.integrate$seurat_clusters==(i-1))
    cluster[index_list[[i]]]=1
    cluster_list[[i]]=cluster
    cluster=rep(0,30672)
    
    
    cluster_train=cluster_list[[i]][separate==0]
    cluster_test=cluster_list[[i]][separate==1]
    
    train=cbind(train,cluster_train)
    train=as.data.frame(train)
    test=cbind(test,cluster_test)
    test=as.data.frame(test)
    
    temp <- (0.5*train$cluster_train*(1/sum(train$cluster_train== 1) - 1/sum(train$cluster_train == 0)) + 0.5/sum(train$cluster_train == 0))
    dat_weights = temp*length(train$cluster_train)
    
    g1=glm(cluster_train~.,data=train, weights=dat_weights, family = 'binomial')
    
    model_list[[i]]=g1
    
    predict=ifelse(g1$fitted.values>0.5,1,0)
    c1=confusionMatrix(data=factor(predict, levels = c(1,0)), reference = factor(cluster_train, levels = c(1,0)))

    
    
    
    predict2=predict(g1,newdata=test,'response')
    predict3=ifelse(predict2>0.5,1,0)
    c2=confusionMatrix(data=factor(predict3, levels = c(1,0)), reference = factor(cluster_test, levels = c(1,0)))
    
    
    train=ADT[separate==0,]
    test=ADT[separate==1,]
}
  
  cluster=rep(0,30672)
  cluster_list=c()
  index_list=c()
  model_list2=c()
  
#Perform logistic regression on each cluster using only RNA information
for(i in 1:16){
    pbmc <- CreateSeuratObject(counts = bm.integrate@assays$RNA@counts[bm.markers$gene[marker_index[[i]]],])
    pbmc <- NormalizeData(pbmc)%>% ScaleData()
    
    rna.emb=t(pbmc@assays$RNA@scale.data)
    colnames(rna.emb) <- noquote(paste('rna',colnames(rna.emb)))
    

    separate <- sample(c(rep(0,21470), rep(1,9202)))
    train=rna.emb[separate==0,]
    test=rna.emb[separate==1,]
    
    index_list[[i]]=which(bm.integrate$seurat_clusters==(i-1))
    cluster[index_list[[i]]]=1
    cluster_list[[i]]=cluster
    cluster=rep(0,30672)
    
    cluster_train=cluster_list[[i]][separate==0]
    cluster_test=cluster_list[[i]][separate==1]
    
    train=cbind(train,cluster_train)
    train=as.data.frame(train)
    test=cbind(test,cluster_test)
    test=as.data.frame(test)
    
    temp <- (0.5*train$cluster_train*(1/sum(train$cluster_train== 1) - 1/sum(train$cluster_train == 0)) + 0.5/sum(train$cluster_train == 0))
    dat_weights = temp*length(train$cluster_train)
    
    g1=glm(cluster_train~.,data=train, weights=dat_weights, family = 'binomial')
    
    model_list2[[i]]=g1

    
    predict=ifelse(g1$fitted.values>0.5,1,0)
    c1=confusionMatrix(data=factor(predict, levels = c(1,0)), reference = factor(cluster_train, levels = c(1,0)))
    
    predict2=predict(g1,newdata=test,'response')
    predict3=ifelse(predict2>0.5,1,0)
    c2=confusionMatrix(data=factor(predict3, levels = c(1,0)), reference = factor(cluster_test, levels = c(1,0)))
    
    train=rna.emb[separate==0,]
    test=rna.emb[separate==1,]
    
}
  
  cluster=rep(0,30672)
  cluster_list=c()
  index_list=c()
  model_list3=c()
  
#Perform logistic regression on each cluster using RNA and ADT information
for(i in 1:16){

    pbmc <- CreateSeuratObject(counts = bm.integrate@assays$RNA@counts[bm.markers$gene[marker_index[[i]]],])
    pbmc <- NormalizeData(pbmc) %>% ScaleData()
    
    rna.emb0=t(pbmc@assays$RNA@scale.data)
  
    colnames(rna.emb0) <- noquote(paste('rna',colnames(rna.emb0)))
 
    rna.emb = cbind(rna.emb0,ADT)
    

    separate <- sample(c(rep(0,21470), rep(1,9202)))
    train=rna.emb[separate==0,]
    test=rna.emb[separate==1,]
    
    
    
    
    index_list[[i]]=which(bm.integrate$seurat_clusters==(i-1))
    cluster[index_list[[i]]]=1
    cluster_list[[i]]=cluster
    cluster=rep(0,30672)
    
    
    cluster_train=cluster_list[[i]][separate==0]
    cluster_test=cluster_list[[i]][separate==1]
    
    train=cbind(train,cluster_train)
    train=as.data.frame(train)
    test=cbind(test,cluster_test)
    test=as.data.frame(test)
    
    temp <- (0.5*train$cluster_train*(1/sum(train$cluster_train== 1) - 1/sum(train$cluster_train == 0)) +  0.5/sum(train$cluster_train == 0))
    dat_weights = temp*length(train$cluster_train)
    
    g1=glm(cluster_train~.,data=train, weights=dat_weights, family = 'binomial')
    
    model_list3[[i]]=g1
    
    predict=ifelse(g1$fitted.values>0.5,1,0)
    c1=confusionMatrix(data=factor(predict, levels = c(1,0)), reference = factor(cluster_train, levels = c(1,0)))

    predict2=predict(g1,newdata=test,'response')
    predict3=ifelse(predict2>0.5,1,0)
    c2=confusionMatrix(data=factor(predict3, levels = c(1,0)), reference = factor(cluster_test, levels = c(1,0)))
    
    train=rna.emb[separate==0,]
    test=rna.emb[separate==1,]
  }

#Find coefficients and p-value for Treg cluster
model_treg_both=model_list[[16]]
summary=summary(model_treg_both)
pvalue=summary$coefficients[,4]
coefficients=data.frame(summary$coefficients[,1])
predictors=rownames(coefficients)[-1]
coefficients=as.data.frame(coefficients[-1,])
coefficients <- as.data.frame(cbind(predictors, coefficients))
coefficients <- coefficients %>% mutate(sign=factor(ifelse(.$`coefficients[-1, ]`>0,'positive','negative'), levels=c('positive','negative')))
coefficients=data.frame(cbind(coefficients, pvalue[-1]))
coefficients <- coefficients %>% mutate(abs.value=ifelse(.$pvalue..1.<0.01, abs(.$coefficients..1...), NA))
coefficients <- subset(coefficients, coefficients$pvalue..1.<0.01)
coefficients <- cbind(coefficients, 'Treg')
colnames(coefficients)[6]='Cluster'
coefficients1 <- coefficients

#Find coefficients and p-value for CD4 Naive cluster
model_cd4n_both=model_list[[2]]
summary=summary(model_cd4n_both)
pvalue=summary$coefficients[,4]
coefficients=data.frame(summary$coefficients[,1])
predictors=rownames(coefficients)[-1]
coefficients=as.data.frame(coefficients[-1,])
coefficients <- as.data.frame(cbind(predictors, coefficients))
coefficients <- coefficients %>% mutate(sign=factor(ifelse(.$`coefficients[-1, ]`>0,'positive','negative'), levels=c('positive','negative')))
coefficients=data.frame(cbind(coefficients, pvalue[-1]))
coefficients <- coefficients %>% mutate(abs.value=ifelse(.$pvalue..1.<0.01, abs(.$coefficients..1...), NA))
coefficients <- cbind(coefficients, 'CD4 Naive')
colnames(coefficients)[6]='Cluster'
coefficients2 <- coefficients

#Find coefficients and p-value for CD4 Memory cluster
model_cd4m_both=model_list[[4]]
summary=summary(model_cd4m_both)
pvalue=summary$coefficients[,4]
pvalue[-1]
coefficients=data.frame(summary$coefficients[,1])
predictors=rownames(coefficients)[-1]
coefficients=as.data.frame(coefficients[-1,])
coefficients <- as.data.frame(cbind(predictors, coefficients))
coefficients <- coefficients %>% mutate(sign=factor(ifelse(.$`coefficients[-1, ]`>0,'positive','negative'), levels=c('positive','negative')))
coefficients=data.frame(cbind(coefficients, pvalue[-1]))
coefficients <- coefficients %>% mutate(abs.value=ifelse(.$pvalue..1.<0.01, abs(.$coefficients..1...), NA))
coefficients <- cbind(coefficients, 'CD4 Memory')
colnames(coefficients)[6]='Cluster'
coefficients3 <- coefficients

#Plot significant coefficients values
coefficients=as.data.frame(rbind(coefficients1, coefficients2, coefficients3))
ggplot(coefficients, aes(x=Cluster,y=predictors, colour=sign, size=abs.value)) + geom_point()+labs(x=NULL)
```
